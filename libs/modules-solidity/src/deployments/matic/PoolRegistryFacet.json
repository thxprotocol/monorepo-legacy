{
  "address": "0x9E17d943229A47ECe6c813af93950c547a8A8f21",
  "abi": [
    {
      "inputs": [],
      "name": "feeCollector",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feePercentage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_feeCollector",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_feePercentage",
          "type": "uint256"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_feeCollector",
          "type": "address"
        }
      ],
      "name": "setFeeCollector",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_feePercentage",
          "type": "uint256"
        }
      ],
      "name": "setFeePercentage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xb744aed30fb5ae23d4b51a52e1a33d97737803085f05785e8ac24688c13e5f9c",
  "receipt": {
    "to": null,
    "from": "0x90819DA17aF39E9791c29a1Cba8819b1084d775a",
    "contractAddress": "0x9E17d943229A47ECe6c813af93950c547a8A8f21",
    "transactionIndex": 61,
    "gasUsed": "224282",
    "logsBloom": "0x00000000000000800000000000000000000000000800000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000201000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000080000000000000000100000000000000000000000000000000000000000000000000000000004000000000000100020",
    "blockHash": "0x31fd4ec6637d8f17abcd3d8d64f4efedb10143e3d973e311432d92e0b8a98d91",
    "transactionHash": "0xb744aed30fb5ae23d4b51a52e1a33d97737803085f05785e8ac24688c13e5f9c",
    "logs": [
      {
        "transactionIndex": 61,
        "blockNumber": 26032833,
        "transactionHash": "0xb744aed30fb5ae23d4b51a52e1a33d97737803085f05785e8ac24688c13e5f9c",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000090819da17af39e9791c29a1cba8819b1084d775a",
          "0x000000000000000000000000127685d6dd6683085da4b6a041efcef1681e5c9c"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000017f5c70d65b560000000000000000000000000000000000000000000000002fac3dbabdcdcd9990000000000000000000000000000000000000000000005efc958b01214fff703000000000000000000000000000000000000000000000002faabe5e4cf7724390000000000000000000000000000000000000000000005efc970a5d92265ac63",
        "logIndex": 208,
        "blockHash": "0x31fd4ec6637d8f17abcd3d8d64f4efedb10143e3d973e311432d92e0b8a98d91"
      }
    ],
    "blockNumber": 26032833,
    "cumulativeGasUsed": "8617905",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "954101db8fd21c30da9bb6a572893bde",
  "metadata": "{\"compiler\":{\"version\":\"0.7.4+commit.3f05b770\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"name\":\"setFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"initialize(address,uint256)\":{\"params\":{\"_feeCollector\":\"Address of the FeeCollector contract.\",\"_feePercentage\":\"Integer representing the deposit fee percentage.\"}},\"setFeeCollector(address)\":{\"params\":{\"_feeCollector\":\"Address of the FeeCollector contract.\"}},\"setFeePercentage(uint256)\":{\"params\":{\"_feePercentage\":\"0 - 10**18 value used for substracting fees from deposits into an asset pool.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PoolRegistry/PoolRegistryFacet.sol\":\"PoolRegistryFacet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/GSN/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3cb350f04ff49cfb10aef08d87f19dcbaecc8027b0bed12f3275cd12f38cf0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0xf7c39c7e6d06ed3bda90cfefbcbf2ddc32c599c3d6721746546ad64946efccaa\",\"license\":\"MIT\"},\"contracts/PoolRegistry/IPoolRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.1;\\n\\ninterface IPoolRegistry {\\n    function initialize(address _feeCollector, uint256 _feePercentage) external;\\n\\n    function setFeeCollector(address _feeCollector) external;\\n\\n    function setFeePercentage(uint256 _feePercentage) external;\\n\\n    function feeCollector() external view returns (address);\\n\\n    function feePercentage() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xbdbfdbd8e510eb2ea52dfdbef6e443a21ad89d23f81f0a6140085e00f6d7f59b\",\"license\":\"Apache-2.0\"},\"contracts/PoolRegistry/LibPoolRegistryStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.4;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\\n\\nlibrary LibPoolRegistryStorage {\\n    bytes32 constant STORAGE_POSITION = keccak256('diamond.standard.poolregistry.storage');\\n\\n    struct Data {\\n        address feeCollector;\\n        uint256 feePercentage;\\n    }\\n\\n    function s() internal pure returns (Data storage bs) {\\n        bytes32 position = STORAGE_POSITION;\\n        assembly {\\n            bs.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x23bded402d052ef405b59c87dfeb67c31fc655769913be28ad349a21f7117430\",\"license\":\"Apache-2.0\"},\"contracts/PoolRegistry/PoolRegistryFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport './IPoolRegistry.sol';\\nimport './LibPoolRegistryStorage.sol';\\n\\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\\n\\ncontract PoolRegistryFacet is IPoolRegistry {\\n    /**\\n     * @param _feeCollector Address of the FeeCollector contract.\\n     * @param _feePercentage Integer representing the deposit fee percentage.\\n     */\\n    function initialize(address _feeCollector, uint256 _feePercentage) external override {\\n        LibDiamond.enforceIsContractOwner();\\n\\n        LibPoolRegistryStorage.Data storage s = LibPoolRegistryStorage.s();\\n        s.feeCollector = _feeCollector;\\n        s.feePercentage = _feePercentage;\\n    }\\n\\n    /**\\n     * @param _feeCollector Address of the FeeCollector contract.\\n     */\\n    function setFeeCollector(address _feeCollector) external override {\\n        LibDiamond.enforceIsContractOwner();\\n\\n        LibPoolRegistryStorage.Data storage s = LibPoolRegistryStorage.s();\\n        s.feeCollector = _feeCollector;\\n    }\\n\\n    /**\\n     * @param _feePercentage 0 - 10**18 value used for substracting fees from deposits into an asset pool.\\n     */\\n    function setFeePercentage(uint256 _feePercentage) external override {\\n        LibDiamond.enforceIsContractOwner();\\n\\n        LibPoolRegistryStorage.Data storage s = LibPoolRegistryStorage.s();\\n        s.feePercentage = _feePercentage;\\n    }\\n\\n    function feeCollector() external view override returns (address) {\\n        return LibPoolRegistryStorage.s().feeCollector;\\n    }\\n\\n    function feePercentage() external view override returns (uint256) {\\n        return LibPoolRegistryStorage.s().feePercentage;\\n    }\\n}\\n\",\"keccak256\":\"0x9e502805698964ec90707c649023cd2e121189bc8535da74bf2d8076ec5eafe7\",\"license\":\"Apache-2.0\"},\"diamond-2/contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x19c92fe16028a8e74a5f1914235b3e7f4e5eafbc5fced9fa345cab5cd4644c0c\",\"license\":\"MIT\"},\"diamond-2/contracts/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* This is gas optimized by reducing storage reads and storage writes.\\n* This code is as complex as it is to reduce gas costs.\\n/******************************************************************************/\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // owner of the contract\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n        _;\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            // get last selectorSlot\\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            require(_newFacetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount % 8) * 32;\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    ds.selectorSlots[_selectorCount / 8] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            require(_newFacetAddress != address(0), \\\"LibDiamondCut: Replace facet can't be address(0)\\\");\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n            uint256 selectorSlotCount = _selectorCount / 8;\\n            uint256 selectorInSlotIndex = (_selectorCount % 8) - 1;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(address(bytes20(oldFacet)) != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n                    // only useful if immutable functions exist\\n                    require(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex * 32));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount / 8;\\n                    oldSelectorInSlotPosition = (oldSelectorCount % 8) * 32;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n                selectorInSlotIndex--;\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex + 1;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x8f7751980297b63c26a4cf8d7830ba82befde6a07b6a179115985c8d04d6b3cd\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610318806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063a001ecdd1461005c578063a42dce801461007a578063ae06c1b71461008f578063c415b95c146100a2578063cd6dc687146100b7575b600080fd5b6100646100ca565b60405161007191906102d9565b60405180910390f35b61008d610088366004610221565b6100dd565b005b61008d61009d36600461026b565b610111565b6100aa61012d565b6040516100719190610283565b61008d6100c5366004610242565b610146565b60006100d461017f565b60010154905090565b6100e56101a3565b60006100ef61017f565b80546001600160a01b0319166001600160a01b03939093169290921790915550565b6101196101a3565b600061012361017f565b6001019190915550565b600061013761017f565b546001600160a01b0316905090565b61014e6101a3565b600061015861017f565b80546001600160a01b0319166001600160a01b039490941693909317835550600190910155565b7fe2cc104856f68c351d4b0b699c8cc1cdeccef04becba293e55ec90e21ae11e8690565b6101ab6101e1565b600401546001600160a01b031633146101df5760405162461bcd60e51b81526004016101d690610297565b60405180910390fd5b565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90565b80356001600160a01b038116811461021c57600080fd5b919050565b600060208284031215610232578081fd5b61023b82610205565b9392505050565b60008060408385031215610254578081fd5b61025d83610205565b946020939093013593505050565b60006020828403121561027c578081fd5b5035919050565b6001600160a01b0391909116815260200190565b60208082526022908201527f4c69624469616d6f6e643a204d75737420626520636f6e7472616374206f776e60408201526132b960f11b606082015260800190565b9081526020019056fea2646970667358221220140d9ce45fd07a873c4cb8847f2eac3798883b190279aa5ddb933ecd9c1e93bb64736f6c63430007040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c8063a001ecdd1461005c578063a42dce801461007a578063ae06c1b71461008f578063c415b95c146100a2578063cd6dc687146100b7575b600080fd5b6100646100ca565b60405161007191906102d9565b60405180910390f35b61008d610088366004610221565b6100dd565b005b61008d61009d36600461026b565b610111565b6100aa61012d565b6040516100719190610283565b61008d6100c5366004610242565b610146565b60006100d461017f565b60010154905090565b6100e56101a3565b60006100ef61017f565b80546001600160a01b0319166001600160a01b03939093169290921790915550565b6101196101a3565b600061012361017f565b6001019190915550565b600061013761017f565b546001600160a01b0316905090565b61014e6101a3565b600061015861017f565b80546001600160a01b0319166001600160a01b039490941693909317835550600190910155565b7fe2cc104856f68c351d4b0b699c8cc1cdeccef04becba293e55ec90e21ae11e8690565b6101ab6101e1565b600401546001600160a01b031633146101df5760405162461bcd60e51b81526004016101d690610297565b60405180910390fd5b565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90565b80356001600160a01b038116811461021c57600080fd5b919050565b600060208284031215610232578081fd5b61023b82610205565b9392505050565b60008060408385031215610254578081fd5b61025d83610205565b946020939093013593505050565b60006020828403121561027c578081fd5b5035919050565b6001600160a01b0391909116815260200190565b60208082526022908201527f4c69624469616d6f6e643a204d75737420626520636f6e7472616374206f776e60408201526132b960f11b606082015260800190565b9081526020019056fea2646970667358221220140d9ce45fd07a873c4cb8847f2eac3798883b190279aa5ddb933ecd9c1e93bb64736f6c63430007040033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "initialize(address,uint256)": {
        "params": {
          "_feeCollector": "Address of the FeeCollector contract.",
          "_feePercentage": "Integer representing the deposit fee percentage."
        }
      },
      "setFeeCollector(address)": {
        "params": {
          "_feeCollector": "Address of the FeeCollector contract."
        }
      },
      "setFeePercentage(uint256)": {
        "params": {
          "_feePercentage": "0 - 10**18 value used for substracting fees from deposits into an asset pool."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}